# HTTP协议

HTTP--Hyper Text Transfer Protocol，超文本传输协议，是一种建立在TCP上的无状态连接，整个基本的工作流程是客户端发送一个HTTP请求

说明客户端想要访问的资源和请求的动作，服务端收到请求之后，服务端开始处理请求，并根据请求做出相应的动作访问服务器资源，最后通过发送HTTP响应把结果返回给客户端。

其中一个请求的开始到一个响应的结束称为事务，当一个事物结束后还会在服务端添加一条日志条目。

* HTTP请求

        HTTP请求是客户端往服务端发送请求动作，告知服务器自己的要求。

        HTTP请求由状态行、请求头、请求正文三部分组成：

        状态行：包括请求方式Method、资源路径URL、协议版本Version；

        请求头：包括一些访问的域名、用户代理、Cookie等信息；

        请求正文：就是HTTP请求的数据。

        备注：请求方式Method一般有GET、POST、PUT、DELETE，含义分别是获取、修改、上传、删除，其中GET方式仅仅为获取服务器资源，
        
        方式较为简单，因此在请求方式为GET的HTTP请求数据中，请求正文部分可以省略，直接将想要获取的资源添加到URL中。

* HTTP响应

    响应数据格式

        服务器收到了客户端发来的HTTP请求后，根据HTTP请求中的动作要求，服务端做出具体的动作，将结果回应给客户端，称为HTTP响应。

        HTTP响应由三部分组成：状态行、响应头、响应正文；

        状态行：包括协议版本Version、状态码Status Code、回应短语；

        响应头：包括搭建服务器的软件，发送响应的时间，回应数据的格式等信息；

        响应正文：就是响应的具体数据。


    HTTP响应模型

        服务器收到HTTP请求之后，会有多种方法响应这个请求，下面是HTTP响应的四种模型：

        单进程I/O模型

        服务端开启一个进程，一个进程仅能处理一个请求，并且对请求顺序处理；

        多进程I/O模型

        服务端并行开启多个进程，同样的一个进程只能处理一个请求，这样服务端就可以同时处理多个请求；

        复用I/O模型

        服务端开启一个进程，但是呢，同时开启多个线程，一个线程响应一个请求，同样可以达到同时处理多个请求，线程间并发执行；

        复用多线程I/O模型

        服务端并行开启多个进程，同时每个进程开启多个线程，这样服务端可以同时处理进程数M*每个进程的线程数N个请求。

* HTTP报文格式

        HTTP报文是HTTP应用程序之间传输的数据块，HTTP报文分为HTTP请求报文和HTTP响应报文，但是无论哪种报文，他的整体格式是类似的，大致都是由起始、首部、主体三部分组成，起始说明报文的动作，首部说明报文的属性，主体则是报文的数据。接下来具体说明。

    HTTP请求报文

        请求报文的起始由请求行构成（有些资料称为状态行，名字不一样而已，都是指的一个东西），用来说明该请求想要做什么，由<Method>、<URL>、<Version> 三个字段组成，注意每个字段之间都有一个空格。

        其中<Method>字段有不同的值：

                GET   --- 访问服务器的资源

                POST  --- 向服务器发送要修改的数据

                HEAD  --- 获取服务器文档的首部

                PUT   --- 向服务器上传资源

                DELETE--- 删除服务器的资源

        <URL>字段表示服务器的资源目录定位

        <Version>字段表示使用的http协议版本

        首部部分由多个请求头（也叫首部行）构成，那些首部字段名有如下，不全：

                Accept     指定客户端能够接收的内容格式类型

                Accept-Language 指定客户端能够接受的语言类型

                Accept-Ecoding  指定客户端能够接受的编码类型

                User-Agent      用户代理，向服务器说明自己的操作系统、浏览器等信息

                Connection      是否开启持久连接（keepalive）

                Host            服务器域名

                ...

        主体部分就是报文的具体数据。                      

    HTTP响应报文

        响应报文的起始由状态行构成，用来说明服务器做了什么，由<Version>、<Status-Code>、<Phrase>三个字段组成，同样的每个字段之间留有空格；

        <Status-Code> 上边已经说明； 

        首部由多个响应头(也叫首部行)组成， 首部字段名如下，不全：

                Server    服务器软件名，Apache/Nginx

                Date      服务器发出响应报文的时间

                Last-Modified   请求资源的最后的修改时间

                ...
        主体部分是响应报文的具体数据。
        
# Http协议三次握手、四次挥手

![Image text](https://upload-images.jianshu.io/upload_images/8141643-ae2a8aa4fdcf49b6.png?imageMogr2/auto-orient)

* 网络协议分层--经典五层模型

    物理层：定义物理设备之间如何传输数据

    数据链路层：在通信的实体间建立数据链路链接

    网络层：为数据在节点之间的传输创建逻辑链路

    传输层：向用户提供可靠的端到端的服务，传输层通过封装向高层屏蔽了下层数据通信的细节

    应用层：为应用软件提供了很多服务，构建于tcp协议之上，屏蔽了网络传输相关的细节

* Http三次握手和四次挥手

        1、Http请求是基于Tcp connection这个链接的

        2、位码即tcp标志位

         SYN(synchronous建立联机) 、ACK(acknowledgement 确认)、 PSH(push传送)  FIN(finish结束)
         
         RST(reset重置)、 URG(urgent紧急) Sequence number(顺序号码)  Acknowledge number(确认号码)

>> 三次握手：

![Image text](https://upload-images.jianshu.io/upload_images/8141643-ef28dc9237f9a1f8.png?imageMogr2/auto-orient)

        第一次握手：主机A发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；

        第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=7654321的包；

        第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。

>> 四次挥手：

![Image text](https://upload-images.jianshu.io/upload_images/8141643-091b4e31a7c4283e.png)

        第一次挥手：TCP发送一个FIN(结束)，用来关闭客户到服务端的连接。

        第二次挥手：服务端收到这个FIN，他发回一个ACK(确认)，确认收到序号为收到序号+1，和SYN一样，一个FIN将占用一个序号。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。（服务器端继续发送未发送完的数据）

        第三次挥手：服务端发送一个FIN(结束)到客户端，服务端关闭客户端的连接。

        第四次挥手：客户端发送ACK(确认)报文确认，并将确认的序号+1，这样关闭完成。

        注：1、那么为什么是4次挥手呢？tcp握手的时候为何ACK(确认)和SYN(建立连接)是一起发送。挥手的时候为什么是分开的时候发送呢？

        因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

>> 为什么客户端最后还要等待2MSL？

        第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

        第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

* TCP和UDP的区别  

1、TCP面向连接（如打电话要先拨号建立连接）；UDP是无连接的，即发送数据之前不需要建立连接  

（连接和无连接）

2、TCP提供可靠的服务。即通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;

     UDP尽最大努力交付，即不保证可靠交付

（可靠和不可靠）

3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的

    UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

（字节流和报文加拥塞）

4、每一条TCP连接只能是点到点的; UDP支持一对一，一对多，多对一和多对多的交互通信

（一对一和一对多）

5、TCP首部开销20字节;UDP的首部开销小，只有8个字节

（开销问题）

6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

简单再了解

1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。

2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。

3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

5、支持B/S及C/S模式。


![Image text](https://upload-images.jianshu.io/upload_images/8141643-258d2838bc7374a9.png?imageMogr2/auto-orient/)